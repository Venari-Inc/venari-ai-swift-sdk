// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.


import Foundation

class _SearchAPI: SearchAPI {
    private let client: Client

    init(client: Client) {
        self.client = client
    }
    
    public func productData(request: Operations.ProductDataRequest) async throws -> Response<Operations.ProductDataResponse> {
        return try await client.makeRequest(
            configureRequest: { configuration in
                try configureProductDataRequest(with: configuration, request: request)
            },
            handleResponse: handleProductDataResponse
        )
    }
    
    public func catalogSearch(request: Operations.CatalogSearchRequest) async throws -> Response<Operations.CatalogSearchResponse> {
        return try await client.makeRequest(
            configureRequest: { configuration in
                try configureCatalogSearchRequest(with: configuration, request: request)
            },
            handleResponse: handleCatalogSearchResponse
        )
    }
    
    public func similarByItem(request: Shared.SimilarItemPayload) async throws -> Response<Operations.SimilarByItemResponse> {
        return try await client.makeRequest(
            configureRequest: { configuration in
                try configureSimilarByItemRequest(with: configuration, request: request)
            },
            handleResponse: handleSimilarByItemResponse
        )
    }

}

// MARK: - Request Configuration

private func configureProductDataRequest(with configuration: URLRequestConfiguration, request: Operations.ProductDataRequest) throws {
    configuration.path = "/v1/sneakers/product_data/{product_id}"
    configuration.method = .get
    configuration.pathParameterSerializable = request
    configuration.queryParameterSerializable = request
    configuration.telemetryHeader = .userAgent
}

private func configureCatalogSearchRequest(with configuration: URLRequestConfiguration, request: Operations.CatalogSearchRequest) throws {
    configuration.path = "/v1/sneakers/search/catalog"
    configuration.method = .get
    configuration.queryParameterSerializable = request
    configuration.telemetryHeader = .userAgent
}

private func configureSimilarByItemRequest(with configuration: URLRequestConfiguration, request: Shared.SimilarItemPayload) throws {
    configuration.path = "/v1/catalog/search/similar_by_item"
    configuration.method = .post
    configuration.contentType = "application/json"
    configuration.body = try jsonEncoder().encode(request)
    if configuration.body == nil {
        throw SerializationError.missingRequiredRequestBody
    }
    configuration.telemetryHeader = .userAgent
}

// MARK: - Response Handlers

private func handleProductDataResponse(response: Client.APIResponse) throws -> Operations.ProductDataResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .productWithUUID(try JSONDecoder().decode(Shared.ProductWithUUID.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    } else if httpResponse.statusCode == 400 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .fourHundredApplicationJsonObject(try JSONDecoder().decode(Operations.ProductDataResponseBody.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    } else if httpResponse.statusCode == 403 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .fourHundredAndThreeApplicationJsonObject(try JSONDecoder().decode(Operations.ProductDataSearchResponseBody.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    } else if httpResponse.statusCode == 500 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .fiveHundredApplicationJsonObject(try JSONDecoder().decode(Operations.ProductDataSearchResponseResponseBody.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handleCatalogSearchResponse(response: Client.APIResponse) throws -> Operations.CatalogSearchResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .twoHundredApplicationJsonSearchResults(try JSONDecoder().decode([Shared.SearchResult].self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    } else if httpResponse.statusCode == 400 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .fourHundredApplicationJsonObject(try JSONDecoder().decode(Operations.CatalogSearchResponseBody.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    } else if httpResponse.statusCode == 403 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .fourHundredAndThreeApplicationJsonObject(try JSONDecoder().decode(Operations.CatalogSearchSearchResponseBody.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    } else if httpResponse.statusCode == 500 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .fiveHundredApplicationJsonObject(try JSONDecoder().decode(Operations.CatalogSearchSearchResponseResponseBody.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handleSimilarByItemResponse(response: Client.APIResponse) throws -> Operations.SimilarByItemResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .searchSimilarByItemResults(try JSONDecoder().decode(Shared.SearchSimilarByItemResults.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    } else if httpResponse.statusCode == 400 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .fourHundredApplicationJsonObject(try JSONDecoder().decode(Operations.SimilarByItemResponseBody.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    } else if httpResponse.statusCode == 403 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .fourHundredAndThreeApplicationJsonObject(try JSONDecoder().decode(Operations.SimilarByItemSearchResponseBody.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    } else if httpResponse.statusCode == 500 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .fiveHundredApplicationJsonObject(try JSONDecoder().decode(Operations.SimilarByItemSearchResponseResponseBody.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

