// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

import Foundation

extension Shared {
    /// A model object
    public struct Variants {
        @DecimalSerialized
        public private(set) var price: Double
        public let sku: String
        @DecimalSerialized
        public private(set) var compareAtPrice: Double?
        @DecimalSerialized
        public private(set) var inventoryQuantity: Double?
        @DecimalSerialized
        public private(set) var position: Double?
        public let productCode: Shared.ProductCode?
        public let size: String?
        public let title: String?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(price: Double, sku: String, compareAtPrice: Double? = nil, inventoryQuantity: Double? = nil, position: Double? = nil, productCode: Shared.ProductCode? = nil, size: String? = nil, title: String? = nil) {
            self._price = DecimalSerialized<Double>(wrappedValue: price)
            self.sku = sku
            self._compareAtPrice = DecimalSerialized<Double?>(wrappedValue: compareAtPrice)
            self._inventoryQuantity = DecimalSerialized<Double?>(wrappedValue: inventoryQuantity)
            self._position = DecimalSerialized<Double?>(wrappedValue: position)
            self.productCode = productCode
            self.size = size
            self.title = title
        }
    }
}

extension Shared.Variants: Codable {
    enum CodingKeys: String, CodingKey {
        case price
        case sku
        case compareAtPrice = "compare_at_price"
        case inventoryQuantity = "inventory_quantity"
        case position
        case productCode = "product_code"
        case size
        case title
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self._price = try container.decode(DecimalSerialized<Double>.self, forKey: .price)
        self.sku = try container.decode(String.self, forKey: .sku)
        self._compareAtPrice = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .compareAtPrice) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self._inventoryQuantity = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .inventoryQuantity) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self._position = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .position) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self.productCode = try container.decodeIfPresent(Shared.ProductCode.self, forKey: .productCode)
        self.size = try container.decodeIfPresent(String.self, forKey: .size)
        self.title = try container.decodeIfPresent(String.self, forKey: .title)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self._price, forKey: .price)
        try container.encode(self.sku, forKey: .sku)
        if self.compareAtPrice != nil {
            try container.encode(self._compareAtPrice, forKey: .compareAtPrice)
        }
        if self.inventoryQuantity != nil {
            try container.encode(self._inventoryQuantity, forKey: .inventoryQuantity)
        }
        if self.position != nil {
            try container.encode(self._position, forKey: .position)
        }
        try container.encodeIfPresent(self.productCode, forKey: .productCode)
        try container.encodeIfPresent(self.size, forKey: .size)
        try container.encodeIfPresent(self.title, forKey: .title)
    }
}

extension Shared.Variants {
    var priceWrapper: DecimalSerialized<Double> {
        return _price
    }
    var compareAtPriceWrapper: DecimalSerialized<Double?> {
        return _compareAtPrice
    }
    var positionWrapper: DecimalSerialized<Double?> {
        return _position
    }
    var inventoryQuantityWrapper: DecimalSerialized<Double?> {
        return _inventoryQuantity
    }
}
